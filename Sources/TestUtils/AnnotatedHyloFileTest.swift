import Core
import Driver
import Utils
import XCTest

extension Diagnostic {

  /// A test annotation that announces `self` should be expected.
  fileprivate var expectation: TestAnnotation {
    TestAnnotation(
      in: site.file.url,
      atLine: site.first().line.number,
      parsing: "diagnostic " + message
    )
  }

}

extension XCTestCase {

  /// The effects of running the `processAndCheck` parameter to `checkAnnotatedHyloFiles`.
  fileprivate typealias ProcessingEffects = (
    /// Test failures generated by processing.
    testFailures: [XCTIssue],
    /// Hylo diagnostics generated by processing.
    diagnostics: DiagnosticSet
  )

  /// Applies `processAndCheck` to `valToTest` and the subset of its annotations whose commands
  /// match `checkedCommands`, recording resulting XCTest failures along with any additional
  /// failures where the effects of processing don't match the its annotation commands ("//!
  /// ... diagnostic ...").
  ///
  /// - Parameters:
  ///   - checkedCommands: the annnotation commands to be validated by `processAndCheck`.
  ///   - processAndCheck: applies some compilation phases to `file`, updating `diagnostics`
  ///     with any generated diagnostics, then checks `annotationsToCheck` against the results,
  ///     returning corresponding test failures. Throws an `Error` if any phases failed.
  fileprivate func checkAnnotations(
    in valToTest: SourceFile,
    checkingAnnotationCommands checkedCommands: Set<String> = [],
    _ processAndCheck: (
      _ file: SourceFile,
      _ annotationsToCheck: ArraySlice<TestAnnotation>,
      _ diagnostics: inout DiagnosticSet
    ) throws -> [XCTIssue]
  ) -> Bool {
    var annotations = TestAnnotation.parseAll(from: valToTest)

    // Separate the annotations to be checked by default diagnostic annotation checking from
    // those to be checked by `processAndCheck`.
    let p = annotations.partition(by: { checkedCommands.contains($0.command) })
    let (diagnosticAnnotations, processingAnnotations) = (annotations[..<p], annotations[p...])

    var diagnostics = DiagnosticSet()
    var processingThrewError = false

    let failures = XCTContext.runActivity(
      named: valToTest.baseName,
      block: { activity in
        let completedProcessingTestFailures = try? processAndCheck(
          valToTest, processingAnnotations, &diagnostics)

        processingThrewError = completedProcessingTestFailures == nil

        return failuresToReport(
          effectsOfProcessing: (
            testFailures: completedProcessingTestFailures ?? [],
            diagnostics: diagnostics
          ),
          unhandledAnnotations: diagnosticAnnotations)
      })

    for f in failures {
      record(f)
    }

    return !processingThrewError
  }

  /// Applies `process` to the ".hylo" file at the given path and reports XCTest failures where the
  /// effects of processing don't match the file's annotation commands ("//! ... diagnostic ...").
  ///
  /// - Parameter process: applies some processing to `file`, updating `diagnostics`
  ///   with any generated diagnostics. Throws an `Error` if processing failed.
  /// - Parameter expectSuccess: true if an error from `process` represents a test failure, false if
  ///   the lack of an error represents a test failure; nil if that information is to be derived
  ///   from the contents of the file.
  public func checkAnnotatedHyloFileDiagnostics(
    inFileAt hyloFilePath: String,
    expectSuccess: Bool,
    _ process: (_ file: SourceFile, _ diagnostics: inout DiagnosticSet) throws -> Void
  ) throws {
    let f = try SourceFile(at: hyloFilePath)

    // FIXME: clarify/explain this code
    let processingSucceeded = checkAnnotations(in: f, checkingAnnotationCommands: []) {
      (f, annotationsToHandle, diagnostics) in
      assert(annotationsToHandle.isEmpty)
      try process(f, &diagnostics)
      return []
    }

    if processingSucceeded != expectSuccess {
      record(
        XCTIssue(
          Diagnostic.error(
            processingSucceeded
              ? "processing succeeded, but failure was expected"
              : "processing failed, but success was expected",
            at: f.wholeRange)))
    }
  }

  /// Given the effects of processing, the annotations not specifically handled by `processAndCheck`
  /// above, returns the final set of test failures to be reported to XCTest.
  fileprivate func failuresToReport(
    effectsOfProcessing processing: ProcessingEffects,
    unhandledAnnotations: ArraySlice<TestAnnotation>
  ) -> [XCTIssue] {
    var testFailures = processing.testFailures

    var diagnosticsByExpectation = Dictionary(
      grouping: processing.diagnostics.elements, by: \.expectation)

    func fail(_ expectation: TestAnnotation, _ message: String) {
      testFailures.append(expectation.failure(message))
    }

    for a in unhandledAnnotations {
      switch a.command {
      case "diagnostic":
        if diagnosticsByExpectation[a]?.popLast() != nil {
        } else {
          fail(a, "missing expected diagnostic\(a.argument.map({": '\($0)'"}) ?? "")")
        }
      case "expect-failure": do {}
      case "expect-success": do {}
      default:
        fail(a, "unexpected test command: '\(a.command)'")
      }
    }

    testFailures += diagnosticsByExpectation.values.joined().lazy.map {
      XCTIssue(.error("unexpected diagnostic: '\($0.message)'", at: $0.site, notes: $0.notes))
    }
    return testFailures
  }

  /// Compiles and runs the val file at `hyloFilePath`, `XCTAssert`ing that diagnostics and exit
  /// codes match annotated expectations.
  public func compileAndRun(_ hyloFilePath: String, expectSuccess: Bool) throws {
    try checkAnnotatedHyloFileDiagnostics(inFileAt: hyloFilePath, expectSuccess: expectSuccess) {
      (hyloSource, diagnostics) in

      var executable: URL

      do {
        executable = try compile(hyloSource.url, with: ["--emit", "binary"])
      } catch let d as DiagnosticSet {
        // Recapture the diagnostics so the annotation testing framework can use them.  The need for
        // this ugliness makes me wonder how important it is to test cli.execute, which after all is
        // just a thin wrapper over cli.executeCommand (currently private).
        diagnostics = d
        throw d
      }

      let (status, _) = try run(executable)
      if status != 0 {
        throw NonzeroExitCode(value: status)
      }
    }
  }

  /// Compiles `input` with the given arguments and returns the URL of the output file, throwing
  /// diagnostics if there are any errors.
  public func compile(_ input: URL, with arguments: [String]) throws -> URL {
    let output = FileManager.default.makeTemporaryFileURL()
    let cli = try Driver.parse(arguments + ["-o", output.relativePath, input.relativePath])
    let (status, diagnostics) = try cli.execute()
    if !status.isSuccess {
      throw diagnostics
    }

    XCTAssert(
      !diagnostics.containsError,
      "CLI reported success but \(input) contains errors: \(diagnostics.rendered())")

    #if os(Windows)
      let executableSuffix = ".exe"
    #else
      let executableSuffix = ""
    #endif

    XCTAssert(
      FileManager.default.fileExists(atPath: output.relativePath + executableSuffix),
      "Compilation output file not found: \(output.relativePath)")

    return output
  }

  /// Runs `executable` and returns its exit status along with the text written to its standard
  /// output.
  public func run(_ executable: URL) throws -> (status: Int32, standardOutput: String) {
    let pipe = Pipe()
    let task = Process()
    task.executableURL = executable
    task.standardOutput = pipe
    try task.run()
    task.waitUntilExit()

    let standardOutput = String(
      data: pipe.fileHandleForReading.readDataToEndOfFile(), encoding: .utf8)
    return (task.terminationStatus, standardOutput ?? "")
  }

}

struct NonzeroExitCode: Error {

  var value: Int32

}
