import FrontEnd

extension Module {

  /// Returns the type of a continuation generated by the projection.
  static func projectionContinuationType() -> AnyType {
    let addressType = AnyType(BuiltinType.ptr)
    let t = AnyType(
      ArrowType(
        receiverEffect: .let,
        environment: .void,
        inputs: [
          CallableTypeParameter(label: nil, type: ^ParameterType(.`let`, addressType))
        ],
        output: .void))
    return ^TupleType(labelsAndTypes: [("resumeFunction", t), ("frame", addressType)])
  }

  /// Returns the type of a continuation that is able to call a caller plateau, projecting a value of type `p`.
  static func plateauContinuationType(projectedType p: AnyType) -> AnyType {
    let addressType = AnyType(BuiltinType.ptr)
    let t = AnyType(
      ArrowType(
        receiverEffect: .let,
        environment: .void,
        inputs: [
          CallableTypeParameter(label: nil, type: ^ParameterType(.`inout`, p)),
          CallableTypeParameter(label: nil, type: ^ParameterType(.`let`, addressType)),
          CallableTypeParameter(
            label: nil, type: ^ParameterType(.`let`, projectionContinuationType())),
        ],
        output: .void))
    return ^TupleType(labelsAndTypes: [("resumeFunction", t), ("frame", addressType)])
  }

  /// Returns the IR function representing the ramp of projection `f`.
  ///
  /// Signature:
  /// > fun Projection.ramp(<parameters>, let PlateauContinuation) -> {}
  ///
  /// Generated function parameters:
  ///   - `<parameters>`: the original parameter of the projection
  ///   - `let PlateauContinuation`: the continuation used to resume the flow in the plateau,
  ///     containing the function to call and the caller frame pointer.
  mutating func demandProjectionRamp(for f: Function.ID) -> Function.ID {
    let result = Function.ID(projectionRamp: f)
    if functions[result] != nil {
      return result
    }

    let source = self[f]
    var inputs = source.inputs
    let c = Self.plateauContinuationType(projectedType: source.output)
    inputs.append(Parameter(decl: nil, type: ParameterType(.`let`, c)))

    let entity = Function(
      isSubscript: false,
      site: source.site,
      linkage: source.linkage,
      genericParameters: source.genericParameters,
      inputs: inputs,
      output: .void,
      blocks: [])
    addFunction(entity, for: result)
    return result
  }

  /// Returns the IR function representing the slide of projection `f`.
  ///
  /// Signature:
  /// > fun Projection.slide(let Builtin.ptr) -> {}
  ///
  /// Generated function parameters:
  ///   - `let Builtin.ptr`: the projection frame pointer.
  mutating func demandProjectionSlide(for f: Function.ID) -> Function.ID {
    let result = Function.ID(projectionSlide: f)
    if self.functions[result] != nil {
      return result
    }

    let source = self[f]
    let inputs = [Parameter(decl: nil, type: ParameterType(.`let`, AnyType(BuiltinType.ptr)))]

    let entity = Function(
      isSubscript: false,
      site: source.site,
      linkage: .module,
      genericParameters: source.genericParameters,
      inputs: inputs,
      output: .void,
      blocks: [])
    addFunction(entity, for: result)
    return result
  }

  /// Returns the IR function representing a plateau region in caller `f` corresponding to the
  /// projected value type `t`.
  ///
  /// Signature:
  /// > fun Caller.plateauN(inout <yield-type>, let Builtin.ptr, let ProjectionContinuation) -> {}
  ///
  /// Generated function parameters:
  ///   - `inout <yield-type>`: the projected value.
  ///   - `let Builtin.ptr`: the address of the caller frame.
  ///   - `let ProjectionContinuation`: the continuation used to resume to the projection's slide,
  ///     containing the function to call and the projection frame pointer.
  mutating func demandPlateau(
    for f: Function.ID, region index: Int, projectedType t: AnyType,
  ) -> Function.ID {
    let result = Function.ID(projectionCallerPlateau: f, region: index)
    if self.functions[result] != nil {
      return result
    }

    let source = self[f]
    let inputs: [Parameter] = [
      Parameter(decl: nil, type: ParameterType(.`inout`, t)),
      Parameter(decl: nil, type: ParameterType(.`let`, AnyType(BuiltinType.ptr))),
      Parameter(decl: nil, type: ParameterType(.`let`, Self.projectionContinuationType())),
    ]

    let entity = Function(
      isSubscript: false,
      site: source.site,
      linkage: .module,
      genericParameters: source.genericParameters,
      inputs: inputs,
      output: .void,
      blocks: [])
    addFunction(entity, for: result)
    return result
  }

}
