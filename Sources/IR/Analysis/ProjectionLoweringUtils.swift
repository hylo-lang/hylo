import FrontEnd

extension Module {

  /// Returns the type of a continuation generated by the projection.
  static func projectionContinuationType() -> AnyType {
    let addressType = AnyType(BuiltinType.ptr)
    let t = AnyType(
      ArrowType(
        receiverEffect: .let,
        environment: .void,
        inputs: [
          CallableTypeParameter(label: nil, type: ^ParameterType(.`let`, addressType))
        ],
        output: .void))
    return ^TupleType([("resumeFunction", t), ("frame", addressType)])
  }

  /// Returns the type of a continuation generated by the projection caller.
  static func callerContinuationType() -> AnyType {
    let addressType = AnyType(BuiltinType.ptr)
    let t = AnyType(
      ArrowType(
        receiverEffect: .let,
        environment: .void,
        inputs: [
          CallableTypeParameter(label: nil, type: ^ParameterType(.`let`, addressType)),
          CallableTypeParameter(
            label: nil, type: ^ParameterType(.`let`, projectionContinuationType())),
        ],
        output: .void))
    return AnyType(
      TupleType([
        TupleType.Element(label: "resumeFunction", type: t),
        TupleType.Element(label: "frame", type: addressType),
      ]))
  }

  /// Returns the IR function representing the ramp of projection `f`.
  ///
  /// Signature:
  /// > fun Projection.ramp(<parameters>, let CallerContinuation, set <yield-type>) -> {}
  mutating func demandProjectionRampDeclaration(for f: Function.ID) -> Function.ID {
    let result = Function.ID(projectionRamp: f)
    if functions[result] != nil {
      return result
    }

    let source = self[f]
    var inputs = source.inputs
    inputs.append(Parameter(decl: nil, type: ParameterType(.`let`, Self.callerContinuationType())))
    inputs.append(Parameter(decl: nil, type: ParameterType(.`set`, source.output)))

    let entity = Function(
      isSubscript: false,
      site: source.site,
      linkage: source.linkage,
      genericParameters: source.genericParameters,
      inputs: inputs,
      output: .void,
      blocks: [])
    addFunction(entity, for: result)
    return result
  }

  /// Returns the IR function representing the slide of projection `f`.
  ///
  /// Signature:
  /// > fun Projection.slide(let Builtin.ptr) -> {}
  mutating func demandProjectionSlideDeclaration(for f: Function.ID) -> Function.ID {
    let result = Function.ID(projectionSlide: f)
    if self.functions[result] != nil {
      return result
    }

    let source = self[f]
    let inputs: [Parameter] = [
      Parameter(decl: nil, type: ParameterType(.`let`, AnyType(BuiltinType.ptr)))
    ]

    let entity = Function(
      isSubscript: false,
      site: source.site,
      linkage: .module,
      genericParameters: source.genericParameters,
      inputs: inputs,
      output: .void,
      blocks: [])
    addFunction(entity, for: result)
    return result
  }

  /// Returns the IR function representing a plateau region in caller `f`.
  ///
  /// Signature:
  /// > fun Caller.plateauN(let Builtin.ptr, let ProjectionContinuation) -> {}
  mutating func demandCallerPlateauDeclaration(
    for f: Function.ID, region index: Int
  ) -> Function.ID {
    let result = Function.ID(projectionCallerPlateau: f, region: index)
    if self.functions[result] != nil {
      return result
    }

    let source = self[f]
    let inputs: [Parameter] = [
      Parameter(decl: nil, type: ParameterType(.`let`, AnyType(BuiltinType.ptr))),
      Parameter(decl: nil, type: ParameterType(.`let`, Self.projectionContinuationType())),
    ]

    let entity = Function(
      isSubscript: false,
      site: source.site,
      linkage: .module,
      genericParameters: source.genericParameters,
      inputs: inputs,
      output: .void,
      blocks: [])
    addFunction(entity, for: result)
    return result
  }

  /// Creates an `Emitter` instance that can modify the IR of `f`, with the insertion point set at
  /// `p` and calls `action` to perform IR emission.
  mutating func modifyIR<T>(
    of f: Function.ID, at p: InsertionPoint, action: (inout Emitter) -> T
  ) -> T {
    var ds = DiagnosticSet()
    return Emitter.withInstance(insertingIn: &self, reportingDiagnosticsTo: &ds) { (e) in
      e.insertionFunction = f
      e.insertionPoint = p
      return action(&e)
    }
  }

  // TODO: remove this
  /// Generates an empty body for `f` by copying the block's scope from `g`.
  mutating func generateEmptyBody(for f: Function.ID, copying g: Function.ID) {
    precondition(f != g)
    let source = self[g]
    let b = self[f].appendBlock(in: source[source.entry!].scope)
    self.modifyIR(of: f, at: .end(of: b)) { (e) in
      e._return()
    }
  }

}
