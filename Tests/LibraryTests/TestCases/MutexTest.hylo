//- compileAndRun expecting: .success

fun increment_100_times_under_lock(_ mutex: Mutex<Int>) {
  var i = 0
  while i < 100 {
    mutex.access(within: fun(_ data: inout Int) {
      &data += 1
    })
    &i += 1
  }
}

public fun main() {
  let mutex: Mutex<Int> = .new(0)

  var t1 = spawn_thread(executing: fun[sink let p=pointer[to: &mutex].copy()]() {
    increment_100_times_under_lock(&(p.copy()).unsafe[])
  })
  var t2 = spawn_thread(executing: fun[sink let p=pointer[to: &mutex].copy()]() {
    increment_100_times_under_lock(&(p.copy()).unsafe[])
  })
  var t3 = spawn_thread(executing: fun[sink let p=pointer[to: &mutex].copy()]() {
    increment_100_times_under_lock(&(p.copy()).unsafe[])
  })

  t1.await()
  t2.await()
  t3.await()

  mutex.access(within: fun(_ data: inout Int) {
    precondition(data == 300)
  })
  let could_lock = mutex.try_access(within: fun(_ data: inout Int) {
    precondition(data == 300)
  })
  precondition(could_lock)
}