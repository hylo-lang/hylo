//- compileAndRun expecting: .success

/// Work provider that doesn't provide any work.
type NoWorkProvider: WorkProvider {

  var dummy: Int // TODO: Workaround for #1699.

  /// Initializes `self` with no work.
  public init() { &dummy = 0}

  /// Provide no work.
  public fun next_work_item(worker_index: Int) inout -> TaskPointer {
    .null()
  }

}

/// A work item that executes a given lambda function.
type SimpleWorkItem<E: Movable & Deinitializable>: Deinitializable {

  var task: TaskBase
  var f: [E]() inout -> Void

  public init(f: sink [E]() inout -> Void) {
    &self.f = f
    TaskBase.`init`(self: &self.task, executing: fun[] (_ task: TaskPointer) -> Void {
      let my_task = PointerToMutable<Self>(type_punning: task)
      my_task.unsafe[].f()
    })
  }

  public fun as_task() inout -> TaskPointer {
    return mutable_pointer[to: &self.task].copy()
  }

}

/// A work provider that provides a single work item, possibly repeating it multiple times.
type SimpleWorkProvider: WorkProvider {

  let work: TaskPointer
  let completed: UInt32
  let repeat_count: Int

  public init(_ work: sink TaskPointer) {
    &self.work = work
    &self.completed = 0
    &self.repeat_count = 1
  }

  public init(_ work: sink TaskPointer, repeat_count: Int) {
    &self.work = work
    &self.completed = 0
    &self.repeat_count = repeat_count.copy()
  }

  public fun next_work_item(worker_index: Int) inout -> TaskPointer {
    let old_value = atomic_add_relaxed_i32(&completed, 1)
    if Int(truncating_or_extending: old_value) < repeat_count {
      return work.copy()
    }
    else {
      return .null()
    }
  }

}

/// A work provider that returns work items from an array, one at a time.
type ArrayWorkProvider: WorkProvider {

  let work: Array<TaskPointer>
  let completed: UInt32

  public init(_ work: sink Array<TaskPointer>) {
    &self.work = work
    &self.completed = 0
  }

  public fun next_work_item(worker_index: Int) inout -> TaskPointer {
    let index = atomic_add_relaxed_i32(&completed, 1)
    let i = Int(truncating_or_extending: index)
    if i < work.count() {
      return work[i].copy()
    }
    else {
      return .null()
    }
  }

}

/// Pause for a while; give a chance to other threads do do some work.
fun pause() {
  for var i in 0 ..< 100 {
    yield_now()
  }
}


fun test_static_thread_pool_with_no_work() {
  let work_provider: NoWorkProvider = .new()
  var pool: StaticWorkerPool<NoWorkProvider> = .new(size: 4, work_provider: mutable_pointer[to: &work_provider])
  pool.await()
}

fun test_static_thread_pool_with_no_work_and_delayed_await() {
  let work_provider: NoWorkProvider = .new()
  var pool: StaticWorkerPool<NoWorkProvider> = .new(size: 4, work_provider: mutable_pointer[to: &work_provider])
  pause()
  pool.await()
}

fun test_executing_one_work_item() {
  var executed = false
  let f = fun[sink let q=mutable_pointer[to: &executed].copy()] () -> Void {
    &(q.copy()).unsafe[] = true
  }
  var work_item = SimpleWorkItem(f: f)
  let work_provider: SimpleWorkProvider = .new(work_item.as_task())
  var pool = StaticWorkerPool(size: 4, work_provider: mutable_pointer[to: &work_provider])
  pool.await()
  precondition(executed, "Work item was not executed.")
}

fun test_executing_multiple_work_items() {
  var count: UInt32 = 0
  let f = fun[sink let q=mutable_pointer[to: &count].copy()] () -> Void {
    _ = atomic_add_relaxed_i32(&(q.copy()).unsafe[], 1)
  }
  var work_item = SimpleWorkItem(f: f)
  let work_provider: SimpleWorkProvider = .new(work_item.as_task(), repeat_count: 10)
  var pool = StaticWorkerPool(size: 4, work_provider: mutable_pointer[to: &work_provider])
  pool.await()
  precondition(count == 10, "We should have 10 work items executed.")
}

fun test_execution_can_park_and_unpark_workers() {
  var count: UInt32 = 0

  // Create work items: 4 active tasks, 4 pauses, and 4 more active tasks.
  let f = fun[sink let q=mutable_pointer[to: &count].copy()] () -> Void {
    _ = atomic_add_relaxed_i32(&(q.copy()).unsafe[], 1)
  }
  var work_item = SimpleWorkItem(f: f)
  let work = Array<TaskPointer>([
    work_item.as_task(), work_item.as_task(), work_item.as_task(), work_item.as_task(),
    .null(), .null(), .null(), .null(),
    work_item.as_task(), work_item.as_task(), work_item.as_task(), work_item.as_task()
  ])

  // Create the thread pool and start executing.
  let work_provider = ArrayWorkProvider(work)
  var pool = StaticWorkerPool(size: 4, work_provider: mutable_pointer[to: &work_provider])

  // Wait until 4 items were executed, and then unpark the workers.
  while Int(truncating_or_extending: atomic_load_relaxed_i32(&count)) < 4 {
    // Wait for the workers to park.
    pause()
  }
  for var i in 0 ..< 4 {
    pool.unpark(index: i)
  }
  pause()

  // Wait for all work items to finish.
  pool.await()
  precondition(count == 8, "We should have 8 work items executed.")
}

fun test_one_unparked_worker_is_enough_to_complete_work() {
  var count: UInt32 = 0

  // Create work items: 4 active tasks, 4 pauses, and 4 more active tasks.
  let f = fun[sink let q=mutable_pointer[to: &count].copy()] () -> Void {
    _ = atomic_add_relaxed_i32(&(q.copy()).unsafe[], 1)
  }
  let work_item = SimpleWorkItem(f: f)
  let work = Array<TaskPointer>([
    work_item.as_task(), work_item.as_task(), work_item.as_task(), work_item.as_task(),
    .null(), .null(), .null(), .null(),
    work_item.as_task(), work_item.as_task(), work_item.as_task(), work_item.as_task()
  ])

  // Create the thread pool and start executing.
  let work_provider = ArrayWorkProvider(work)
  var pool = StaticWorkerPool(size: 4, work_provider: mutable_pointer[to: &work_provider])

  // Wait until 4 items were executed, and then unpark just one worker.
  while Int(truncating_or_extending: atomic_load_relaxed_i32(&count)) < 4 {
    // Wait for the workers to park.
    pause()
  }
  pool.unpark(index: 0)
  pause()

  // Wait for all work items to finish.
  pool.await()
  precondition(count == 8, "We should have 8 work items executed.")
}

public fun main() {
  #if os(Linux) || os(macOS)
    test_static_thread_pool_with_no_work()
    test_static_thread_pool_with_no_work_and_delayed_await()
    test_executing_one_work_item()
    test_executing_multiple_work_items()
    test_one_unparked_worker_is_enough_to_complete_work()
  #endif
}