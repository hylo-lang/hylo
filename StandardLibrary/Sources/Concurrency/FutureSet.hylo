/// A future that is able to await multiple work items to complete (generated by a bulk spawn).
public type FutureSet<E: Movable & Deinitializable> {

  /// The underlying frame object that is used to connect the spawned set of computations with the await point.
  private var frame: PointerToMutable<BulkSpawnFrame<E>>

  /// Initializes `self` with `action`, and spawns the computation.
  ///
  /// `action` will eventually be called for all the indices in range [0, count).
  public init(count: Int, action: sink [E](index: Int) -> Void) {
    &self.frame = BulkSpawnFrame<E>.allocate_and_spawn(count: count, action: action)
  }

  /// Awaits the result of the computation.
  ///
  /// - Note: May return on a different OS thread than the one that called this.
  public fun await() sink {
    (&frame.unsafe[]).await()
    frame.deallocate()
  }

}

public type BulkSpawnFrame<E: Movable & Deinitializable> {

  /// What needs to be called to produce the value in the future.
  private var f: [E](index: Int) -> Void

  /// The start of the underlying frame object.
  private let base: BulkSpawnFrameBase

  /// Creates an object of `Self`, initializes it with `f` and spawn the work.
  public static fun allocate_and_spawn(count: Int, action: sink [E](index: Int) -> Void) -> PointerToMutable<Self> {
    // Allocate the frame.
    let base_size = Int(truncating_or_extending: concore2full_frame_size(count: Int32(truncating_or_extending: count)))
    let size_to_alloc = base_size + MemoryLayout<Self>.size() - MemoryLayout<BulkSpawnFrameBase>.size()
    let storage = MemoryAddress.allocate_bytes(count: size_to_alloc, aligned_at: (MemoryLayout<Self>.alignment()))
    let p = PointerToMutable<Self>(type_punning: storage)
    &p.unsafe[].f = action
    &p.unsafe[].base = .new()

    // Spawn the work.
    inout local_action = fun (_ frame: inout BulkSpawnFrameBase, _ index_ptr: inout UInt64) -> Void {
      // The backend sends an integer, but we capture it as a pointer; transform it back to an integer.
      let index = Int(bit_pattern: MemoryAddress(type_punning: mutable_pointer[to: &index_ptr]))

      var this = Self.base_to_self(&frame)
      this.unsafe[].f(index: Int(truncating_or_extending: index))
    }
    concore2full_bulk_spawn2(&p.unsafe[].base, Int32(truncating_or_extending: count), local_action)

    return p
  }

  /// Awaits for the bulk spawn to complete.
  ///
  /// - Note: May return on a different OS thread than the one that called this.
  internal fun await() inout {
    concore2full_bulk_await(&self.base)
  }

  /// Converts from a base frame to the `Self` object containing it.
  static fun base_to_self(_ base: inout BulkSpawnFrameBase) -> PointerToMutable<Self> {
    let base_address = Int(bit_pattern: MemoryAddress(type_punning: mutable_pointer[to: &base]))
    var self_address = base_address - MemoryLayout<[E](index: Int) -> Void>.size()
    self_address -= self_address % MemoryLayout<Self>.alignment()
    return PointerToMutable<Self>(bit_pattern: self_address)
  }

}

/// Describes the frame needed to bulk spawn a set of computations.
///
/// Needs to be aligned as a pointer; the size will be `concore2full_frame_size(count)`.
public type BulkSpawnFrameBase: Deinitializable, Movable {

  let p1: MemoryAddress
  // other data to follow; use `concore2full_frame_size` to determine the size.

  public init() {
    &self.p1 = .null()
  }
}

/// Gets the size of a frame for bulk spawning `count` work items.
@external("concore2full_frame_size")
fun concore2full_frame_size(count: Int32) -> UInt64;

/// Spawns the execution of `f` using control data `frame`.
@external("concore2full_bulk_spawn2")
fun concore2full_bulk_spawn2(
  _ frame: set BulkSpawnFrameBase,
  _ count: Int32,
  _ f: [](inout BulkSpawnFrameBase, inout UInt64) let -> Void);

/// Awaits the completion of the computation started in `frame`.
@external("concore2full_bulk_await")
fun concore2full_bulk_await(_ frame: BulkSpawnFrameBase);
