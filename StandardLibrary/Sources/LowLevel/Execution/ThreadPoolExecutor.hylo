/// Executor backed by a fixed-size thread pool.
public type ThreadPoolExecutor: Movable, Deinitializable {

  var workers: StaticWorkerPool<NoWorkProvider>

  /// Initializes `self` with `n` worker threads.
  public init(size n: Int) {
    StaticWorkerPool<NoWorkProvider>.`init`(self: &workers, size: n, work_provider: .new())
  }

  // TODO (#1688): We should not have this; instead users should explicitly call `await()`.
  public fun deinit() sink {
    precondition(false, "Call `await()` instead of `deinit()` on `ThreadPoolExecutor` object.")
    &self.await()
  }

  /// Returns the number of available threads in the pool.
  public fun available_parallelism() -> Int {
    return workers.available_parallelism()
  }

  /// Enqueues `task` to be executed threads in `self`.
  public fun enqueue(_ task: TaskPointer) {
    // TODO
  }

  /// If `task` did not start executing yet, it will be removed from the queue.
  /// Returns `true` if the task was removed from the queue.
  public fun extract(_ task: TaskPointer) -> Bool {
    // TODO
    return false
  }

  /// Awaits for all the tasks to complete, and closes the executor.
  public fun await() sink {
    &workers.await()
  }

  /// Work provider that doesn't provide any work.
  type NoWorkProvider: WorkProvider {

    /// Initializes `self` with no work.
    public init() {}

    /// Provide no work.
    public fun next_work_item(worker_index: Int) inout -> TaskPointer {
      .null()
    }

  }

}
