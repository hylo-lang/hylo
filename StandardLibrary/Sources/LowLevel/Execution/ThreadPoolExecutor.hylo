/// Executor backed by a fixed-size thread pool.
public type ThreadPoolExecutor: Movable, Deinitializable {

  /// Central object that manages the tasks that need to be executed.
  var work_provider: LIFOWorkProvider
  /// The worker pool that will execute the tasks.
  var workers: StaticWorkerPool<LIFOWorkProvider>

  /// Initializes `self` with `n` worker threads.
  public init(size n: Int) {
    &self.work_provider = .new()
    StaticWorkerPool<LIFOWorkProvider>.`init`(self: &workers, size: n, work_provider: mutable_pointer[to: &work_provider])
  }

  // TODO (#1688): We should not have this; instead users should explicitly call `await()`.
  public fun deinit() sink {
    precondition(false, "Call `await()` instead of `deinit()` on `ThreadPoolExecutor` object.")
    &self.await()
  }

  /// Returns the number of available threads in the pool.
  public fun available_parallelism() -> Int {
    return workers.available_parallelism()
  }

  /// Enqueues `task` to be executed threads in `self`.
  public fun enqueue(_ task: TaskPointer) {
    // TODO
  }

  /// If `task` did not start executing yet, it will be removed from the queue.
  /// Returns `true` if the task was removed from the queue.
  public fun extract(_ task: TaskPointer) -> Bool {
    // TODO
    return false
  }

  /// Awaits for all the tasks to complete, and closes the executor.
  public fun await() sink {
    &workers.await()
  }

}
