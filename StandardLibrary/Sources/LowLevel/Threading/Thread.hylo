
/// A unique identifier for a running thread.
///
/// This is an abstraction over the thread ID for the underlying operating system.
public type ThreadId {

  /// The underlying thread ID, as seen by the operating system.
  var id: pthread_t

  /// Initializes `self` with the given operating system thread ID.
  // TODO: usable from inline; needs to be internal
  public init(os_value: pthread_t) {
    &id = .new(truncating_or_extending: os_value)
  }

  /// Returns `self` as a numeric value.
  public fun numeric_value() -> UInt64 {
    UInt64(truncating_or_extending: id)
  }

}
conformance ThreadId: Regular {}


/// Handler for a thread that is being executed.
///
/// This allows the caller to wait for the thread to complete. The caller needs to ensure that the
/// thread joins before the handler is destroyed.
///
/// TODO: return type should be generic
public type ThreadCompletion<E: Deinitializable & Movable> {

  /// The closure that is being executed by the thread.
  // var closure: [E]() -> Void
  var closure_data: E

  /// The underlying thread object, as seen by the operating system.
  var thread: OSThread

  /// Initializes `self` with the given operating system thread object.
  internal init(stack: UInt, executing f: sink [E]() -> Void) {
    // Closure has the type: { ptr-to-fun, { closure-data...: E } }
    let closure_address = take_address(&f)
    let function_ptr = deref(closure_address)
    let closure_data_ptr = closure_address.advance(by: MemoryLayout<MemoryAddress>.size())
    &self.closure_data = PointerToMutable<E>(type_punning: closure_data_ptr).unsafe_pointee()
    &self.thread = OSThread.spawn_thread(stack: stack.copy(), executing: function_ptr, with_argument: take_address(&self.closure_data))
  }

  /// Returns the unique identifier for the thread.
  public fun thread_id() -> ThreadId {
    .new(os_value: thread.id())
  }

  /// Awaits for the thread to complete
  public fun await() sink {
    &thread.join()
  }

  /// Returns the address of `x` as a `MemoryAddress`.
  private static fun take_address<T>(_ x: inout T) -> MemoryAddress {
    return MemoryAddress(type_punning: mutable_pointer[to: &x])
  }

  /// Dereferences `o` and returns the value as a pointer.
  private static fun deref(_ p: MemoryAddress) -> MemoryAddress {
    return PointerToMutable<MemoryAddress>(type_punning: p).unsafe_pointee()
  }

}

/// Creates a new thread that will execute `f`.
public fun spawn_thread<E: Deinitializable & Movable>(executing f: sink [E]() -> Void) -> ThreadCompletion<E> {
  .new(stack: 0, executing: f)
}

/// Creates a new thread that will execute `f`, using a stack size of `stack_size`.
public fun spawn_thread<E: Deinitializable & Movable>(stack_size: UInt, executing f: sink [E]() -> Void) -> ThreadCompletion<E> {
  .new(stack: stack_size, executing: f)
}

/// Returns the unique identifier for the current thread.
public fun current_thread_id() -> ThreadId {
  .new(os_value: pthread_self())
}

/// Yields the current execution time slice to the operating system.
public fun yield_now() {
  OSThread.yield_now()
}

/// Returns the available parallelism on the system.
///
/// In case we cannot find the number of processors, we return `0`.
public fun available_parallelism() -> Int {
  OSThread.available_parallelism()
}
