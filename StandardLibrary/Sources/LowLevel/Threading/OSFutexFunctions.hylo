let SYS_futex: c_long = 98
let FUTEX_WAIT: c_int = 0
let FUTEX_WAKE: c_int = 1
let FUTEX_WAIT_PRIVATE: c_int = 128
let FUTEX_WAKE_PRIVATE: c_int = 129


/// Sleep until the value at `futex` changes to a value different than `expected`.
internal fun futex_wait(futex: inout UInt32, expected: UInt32) {
  while true {
    // No need to wait if the value already changed.
    var value: UInt32 = .new(value: Builtin.atomic_load_relaxed_i32(Builtin.address(of: futex.value)))
    if ( value != expected ) {
      break
    }

    // Make a system call to wait for the value to change.
    let _ = syscall_for_futex(
      number: SYS_futex,
      uaddr: MemoryAddress(type_punning: mutable_pointer[to: &futex]),
      futex_op: FUTEX_WAIT_PRIVATE,
      val: 0,
      timeout: .null(),
      uaddr2: .null(),
      val3: 0)
  }
}

/// Wake up `threads_to_wake` threads waiting on `futex`. Returns the number of threads woken up.
internal fun futex_wake(futex: inout UInt32, threads_to_wake: UInt32) -> UInt32 {
  var r = syscall_for_futex(
    number: SYS_futex,
    uaddr: MemoryAddress(type_punning: mutable_pointer[to: &futex]),
    futex_op: FUTEX_WAKE_PRIVATE,
    val: threads_to_wake,
    timeout: .null(),
    uaddr2: .null(),
    val3: 0)
  return .new(truncating_or_extending: r)
}
